using CONST = Bogus.CLI.App.Constants;
using Bogus.CLI.App.Helpers.Interface;
using Bogus.CLI.App.Services.Interface;

namespace Bogus.CLI.App.Services;
public class DatasetService(
    IDatasetHelper datasetHelper,
    IFakerService fakerService,
    IFakeDataLoremService fakeDataLoremService,
    IFakeDataNameService fakeDataNameService,
    IFakeDataPhoneService fakeDataPhoneService) : IDatasetService
{
    private readonly IDatasetHelper _datasetHelper = datasetHelper;
    private readonly IFakerService _fakerService = fakerService;
    private readonly IFakeDataLoremService _fakeDataLoremService = fakeDataLoremService;
    private readonly IFakeDataNameService _fakeDataNameService = fakeDataNameService;
    private readonly IFakeDataPhoneService _fakeDataPhoneService = fakeDataPhoneService;

    public List<List<(string Value, string Alias)>> ExecuteCommand(
        string[] datasets, int count, string? locale, string? parameters, out string message)
    {
        // Controls the randomness of the values generated by the Bogus library.
        Randomizer.Seed = new Random();

        _fakerService.LocaleCode = locale ?? string.Empty;

        var results = new List<List<(string DatasetValue, string Alias)>>();
        if (!_datasetHelper.TryParseParameters(parameters, out var parsedParams))
        {
            message = "Sorry, but there is an issue with the parameters option. Please check.";
            return results;
        }

        if (count <= 0)
        {
            message = "The option --count must be greater than 1.";
            return results;
        }

        // Pre-processing: validation and extraction of information from datasets.
        var datasetInfos = new List<(
            string DatasetName,
            string PropertyName,
            string Alias,
            Func<string, IDictionary<string, object>, string?> Generator)>();

        foreach (var dataset in datasets)
        {
            if (!_datasetHelper.TryParseDataset(
                dataset, out string datasetName, out string propertyName, out string alias))
            {
                message = $"Invalid format for dataset: {dataset}. Use <dataset.sub-option>.";
                return results;
            }

            if (!_datasetHelper.DatasetExists(datasetName))
            {
                message = $"Dataset '{datasetName}' not found.";
                return results;
            }

            if (!_datasetHelper.PropertyExists(datasetName, propertyName))
            {
                message = $"The '{datasetName}' does not contain the property '{propertyName}'.";
                return results;
            }

            Func<string, IDictionary<string, object>, string?> generator = datasetName switch
            {
                CONST.Datasets.LOREM => _fakeDataLoremService.Generate,
                CONST.Datasets.NAME => _fakeDataNameService.Generate,
                CONST.Datasets.PHONE => _fakeDataPhoneService.Generate,
                _ => (_, _) => null
            };

            datasetInfos.Add((datasetName, propertyName, alias, generator));
        }

        // Main processing
        for (int i = 0; i < count; i++)
        {
            var row = new List<(string Value, string Alias)>();
            foreach (var (datasetName, propertyName, alias, generator) in datasetInfos)
            {
                var value = generator(propertyName, parsedParams);

                if (string.IsNullOrEmpty(value))
                {
                    message = $"Dataset or property unknown: {datasetName}.{propertyName}";
                    return results;
                }

                row.Add((Value: value, Alias: alias));
            }

            results.Add(row);
        }

        message = string.Empty;
        return results;
    }
}
